## ความเป็นเจ้าของคืออะไร?

_ความเป็นเจ้าของ (Ownership)_ คือชุดของกฎเกณฑ์ที่ควบคุมวิธีการจัดการหน่วยความจำของโปรแกรม Rust โปรแกรมทั้งหมดต้องจัดการวิธีการใช้หน่วยความจำของคอมพิวเตอร์ในขณะที่ทำงาน บางภาษามีกลไกการเก็บขยะ (garbage collection) ซึ่งจะค้นหาหน่วยความจำที่ไม่ได้ใช้อีกต่อไปเป็นประจำในขณะที่โปรแกรมทำงาน ในภาษาอื่นๆ โปรแกรมเมอร์จะต้องจัดสรรและคืนหน่วยความจำด้วยตนเอง Rust ใช้วิธีที่สาม: หน่วยความจำได้รับการจัดการผ่านระบบความเป็นเจ้าของพร้อมชุดของกฎเกณฑ์ที่คอมไพเลอร์ตรวจสอบ หากมีการละเมิดกฎใดๆ โปรแกรมจะไม่สามารถคอมไพล์ได้ คุณสมบัติใดๆ ของความเป็นเจ้าของจะไม่ทำให้โปรแกรมของคุณทำงานช้าลงในขณะที่ทำงาน

เนื่องจากความเป็นเจ้าของเป็นแนวคิดใหม่สำหรับโปรแกรมเมอร์หลายคน จึงต้องใช้เวลาพอสมควรในการทำความคุ้นเคย ข่าวดีคือยิ่งคุณมีประสบการณ์กับ Rust และกฎของระบบความเป็นเจ้าของมากขึ้นเท่าไหร่ คุณก็จะพบว่าการพัฒนาโค้ดที่ปลอดภัยและมีประสิทธิภาพเป็นเรื่องง่ายขึ้นโดยธรรมชาติ พยายามต่อไป!

เมื่อคุณเข้าใจความเป็นเจ้าของแล้ว คุณจะมีพื้นฐานที่มั่นคงสำหรับการทำความเข้าใจคุณสมบัติที่ทำให้ Rust มีเอกลักษณ์เฉพาะตัว ในบทนี้ คุณจะได้เรียนรู้ความเป็นเจ้าของโดยการศึกษาตัวอย่างบางส่วนที่เน้นไปที่โครงสร้างข้อมูลที่ใช้กันทั่วไปมาก นั่นคือ สตริง (strings)

> ### The Stack and the Heap
>
> ภาษาโปรแกรมจำนวนมากไม่ต้องการให้คุณคิดถึงสแต็กและฮีปบ่อยนัก แต่ในภาษาโปรแกรมเชิงระบบอย่าง Rust ไม่ว่าค่าจะอยู่บนสแต็กหรือฮีป จะส่งผลต่อลักษณะการทำงานของภาษาและเหตุผลที่คุณต้องตัดสินใจบางอย่าง ส่วนต่างๆ ของความเป็นเจ้าของจะอธิบายโดยอ้างอิงถึงสแต็กและฮีปในส่วนต่อๆ ไปของบทนี้ ดังนั้นนี่คือคำอธิบายสั้นๆ เพื่อเตรียมความเข้าใจ
>ทั้งสแต็กและฮีปเป็นส่วนหนึ่งของหน่วยความจำที่โค้ดของคุณสามารถใช้งานได้ในขณะรันไทม์ แต่มีโครงสร้างที่แตกต่างกัน สแต็กจัดเก็บค่าตามลำดับที่ได้รับและนำค่าออกในลำดับที่ตรงกันข้าม ซึ่งเรียกว่า _เข้าหลัง ออกก่อน_ ลองนึกถึงกองจาน เมื่อคุณเพิ่มจานมากขึ้น คุณจะวางไว้บนสุดของกอง และเมื่อคุณต้องการจาน คุณจะหยิบจากด้านบน การเพิ่มหรือนำจานออกจากตรงกลางหรือด้านล่างจะไม่ได้ผลดีเท่า! การเพิ่มข้อมูลเรียกว่า การพุชลงบนสแต็ก และการนำข้อมูลออกเรียกว่า _การป็อปออกจากสแต็ก_ ข้อมูลทั้งหมดที่จัดเก็บไว้ในสแต็กต้องมีขนาดที่ทราบและคงที่ ข้อมูลที่มีขนาดไม่ทราบในเวลาคอมไพล์หรือขนาดที่อาจเปลี่ยนแปลงได้จะต้องจัดเก็บไว้ในฮีปแทน
> 
>ฮีปมีการจัดระเบียบน้อยกว่า เมื่อคุณวางข้อมูลบนฮีป คุณจะร้องขอพื้นที่จำนวนหนึ่ง ตัวจัดสรรหน่วยความจำจะค้นหาพื้นที่ว่างในฮีปที่มีขนาดใหญ่พอ 
>ทำเครื่องหมายว่ากำลังใช้งานอยู่ และส่งคืน _พอยน์เตอร์_ ซึ่งเป็นที่อยู่ของตำแหน่งนั้น กระบวนการนี้เรียกว่า การจัดสรรบนฮีป และบางครั้งย่อว่า _การจัดสรร_
>(การพุชค่าลงบนสแต็กไม่ถือเป็นการจัดสรร) เนื่องจากพอยน์เตอร์ไปยังฮีปมีขนาดที่ทราบและคงที่ คุณจึงสามารถจัดเก็บพอยน์เตอร์บนสแต็กได้ แต่เมื่อคุณต้องการข้อมูลจริง 
>คุณจะต้องตามพอยน์เตอร์ไป ลองนึกถึงการนั่งอยู่ในร้านอาหาร เมื่อคุณเข้าไป คุณจะแจ้งจำนวนคนในกลุ่มของคุณ และเจ้าหน้าที่ต้อนรับจะหาโต๊ะว่างที่พอดีกับทุกคนและนำคุณไปที่นั่น 
>หากมีคนในกลุ่มของคุณมาสาย พวกเขาสามารถถามได้ว่าคุณนั่งอยู่ที่ไหนเพื่อตามหาคุณ
>
>
>การพุชลงบนสแต็กเร็วกว่าการจัดสรรบนฮีป เนื่องจากตัวจัดสรรไม่จำเป็นต้องค้นหาสถานที่จัดเก็บข้อมูลใหม่ ตำแหน่งนั้นจะอยู่ที่ด้านบนของสแต็กเสมอ
>ในทางตรงกันข้าม การจัดสรรพื้นที่บนฮีปต้องใช้ความพยายามมากขึ้น เนื่องจากตัวจัดสรรต้องค้นหาพื้นที่ขนาดใหญ่พอที่จะเก็บข้อมูลก่อน จากนั้นจึงดำเนินการบันทึกบัญชีเพื่อเตรียมพร้อมสำหรับการจัดสรรครั้งต่อไป
>
> การเข้าถึงข้อมูลในฮีปช้ากว่าการเข้าถึงข้อมูลบนสแต็ก เนื่องจากคุณต้องตามพอยน์เตอร์เพื่อไปถึงที่นั่น 
> โปรเซสเซอร์สมัยใหม่จะทำงานได้เร็วกว่าหากมีการกระโดดไปมาในหน่วยความจำน้อยลง ลองพิจารณาบริกรในร้านอาหารที่รับออเดอร์จากหลายโต๊ะ 
> การรับออเดอร์ทั้งหมดที่โต๊ะหนึ่งก่อนที่จะไปยังโต๊ะถัดไปมีประสิทธิภาพมากที่สุด การรับออเดอร์จากโต๊ะ A แล้วรับจากโต๊ะ B แล้วกลับไปรับจาก A อีกครั้ง แล้วจึงรับจาก B อีกครั้ง จะเป็นกระบวนการที่ช้ากว่ามาก ในทำนองเดียวกัน 
> โปรเซสเซอร์สามารถทำงานได้ดีขึ้นหากทำงานกับข้อมูลที่อยู่ใกล้กับข้อมูลอื่นๆ (เช่น บนสแต็ก) แทนที่จะอยู่ห่างไกล (เช่น บนฮีป)
>
> เมื่อโค้ดของคุณเรียกใช้ฟังก์ชัน ค่าที่ส่งไปยังฟังก์ชัน (รวมถึงพอยน์เตอร์ไปยังข้อมูลบนฮีปด้วย) และตัวแปรเฉพาะของฟังก์ชันจะถูกพุชลงบนสแต็ก เมื่อฟังก์ชันสิ้นสุดลง ค่าเหล่านั้นจะถูกป็อปออกจากสแต็ก
>
> การติดตามว่าส่วนใดของโค้ดกำลังใช้ข้อมูลใดบนฮีป การลดปริมาณข้อมูลที่ซ้ำซ้อนบนฮีป และการล้างข้อมูลที่ไม่ได้ใช้ออกไปจากฮีปเพื่อไม่ให้หน่วยความจำหมด เป็นปัญหาทั้งหมดที่ความเป็นเจ้าของเข้ามาจัดการ เมื่อคุณเข้าใจความเป็นเจ้าของแล้ว คุณจะไม่จำเป็นต้องคิดถึงสแต็กและฮีปบ่อยนัก แต่การรู้ว่าวัตถุประสงค์หลักของความเป็นเจ้าของคือการจัดการข้อมูลบนฮีปสามารถช่วยอธิบายได้ว่าทำไมมันถึงทำงานในลักษณะที่เป็นอยู่

### กฎของความเป็นเจ้าของ

ก่อนอื่น เรามาดูกฎของความเป็นเจ้าของกัน โปรดจำกฎเหล่านี้ไว้ในขณะที่เราศึกษาตัวอย่างที่แสดงให้เห็นกฎเหล่านี้:

- ค่าแต่ละค่าใน Rust มี _เจ้าของ_
- มีเจ้าของได้เพียงคนเดียว ณ เวลาใดเวลาหนึ่ง
- เมื่อเจ้าของหลุดออกจากขอบเขต (scope) ค่าดังกล่าวจะถูกทิ้ง (dropped)

### ขอบเขตของตัวแปร

ตอนนี้เราได้ผ่านไวยากรณ์พื้นฐานของ Rust ไปแล้ว เราจะไม่ใส่โค้ด `fn main() {` ทั้งหมดในตัวอย่าง ดังนั้นหากคุณกำลังทำตาม โปรดตรวจสอบให้แน่ใจว่าได้ใส่ตัวอย่างต่อไปนี้ไว้ในฟังก์ชัน `main` ด้วยตนเอง 
ด้วยเหตุนี้ ตัวอย่างของเราจะกระชับขึ้นเล็กน้อย ทำให้เราสามารถมุ่งเน้นไปที่รายละเอียดที่แท้จริงแทนที่จะเป็นโค้ดส่วนเกิน

ในฐานะตัวอย่างแรกของความเป็นเจ้าของ เราจะมาดู _ขอบเขต_ ของตัวแปรบางตัว ขอบเขตคือช่วงภายในโปรแกรมที่รายการนั้นถูกต้อง ลองพิจารณาตัวแปรต่อไปนี้:

```rust
let s = "hello";
```

ตัวแปร `s` อ้างอิงถึงตัวอักษรสตริง ซึ่งค่าของสตริงถูกฮาร์ดโค้ดไว้ในข้อความของโปรแกรม ตัวแปรนี้จะใช้งานได้ตั้งแต่จุดที่ประกาศจนถึงสิ้นสุด _ขอบเขต_ ปัจจุบัน รายการที่ 4-1 แสดงโปรแกรมที่มีความคิดเห็นกำกับว่าตัวแปร s จะใช้งานได้ที่ใด

<Listing number="4-1" caption="A variable and the scope in which it is valid">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

</Listing>

กล่าวอีกนัยหนึ่ง มีสองช่วงเวลาที่สำคัญในที่นี้:

- เมื่อ `s` _เข้าสู่_ ขอบเขต มันจะใช้งานได้
- มันจะยังคงใช้งานได้จนกว่ามันจะ _ออกจาก_ ขอบเขต

ณ จุดนี้ ความสัมพันธ์ระหว่างขอบเขตและช่วงเวลาที่ตัวแปรใช้งานได้นั้นคล้ายคลึงกับในภาษาโปรแกรมอื่นๆ ตอนนี้เราจะต่อยอดจากความเข้าใจนี้โดยการแนะนำชนิดข้อมูล `String`

### ชนิดข้อมูล `String`

เพื่อแสดงให้เห็นกฎของความเป็นเจ้าของ เราต้องการชนิดข้อมูลที่ซับซ้อนกว่าชนิดข้อมูลที่เรากล่าวถึงในส่วน [“Data Types”][data-types]<!-- ignore --> 
ชนิดข้อมูลที่กล่าวถึงก่อนหน้านี้มีขนาดที่ทราบ สามารถจัดเก็บไว้ในสแต็กและนำออกจากสแต็กเมื่อขอบเขตของมันสิ้นสุดลง และสามารถคัดลอกได้อย่างรวดเร็วและง่ายดายเพื่อสร้างอินสแตนซ์ใหม่ที่เป็นอิสระ 
หากส่วนอื่นของโค้ดต้องการใช้ค่าเดียวกันในขอบเขตที่แตกต่างกัน แต่เราต้องการดูข้อมูลที่จัดเก็บไว้ในฮีป และสำรวจว่า Rust รู้ได้อย่างไรว่าจะล้างข้อมูลนั้นเมื่อใด และชนิดข้อมูล `String` เป็นตัวอย่างที่ดี

เราจะมุ่งเน้นไปที่ส่วนต่างๆ ของ `String` ที่เกี่ยวข้องกับความเป็นเจ้าของ ลักษณะเหล่านี้ยังใช้ได้กับชนิดข้อมูลที่ซับซ้อนอื่นๆ
ไม่ว่าจะเป็นชนิดข้อมูลที่มาจากไลบรารีมาตรฐานหรือชนิดข้อมูลที่คุณสร้างขึ้นเอง เราจะกล่าวถึง `String` ในรายละเอียดเพิ่มเติมใน[Chapter 8][ch8]<!-- ignore -->.

เราได้เห็นตัวอักษรสตริงแล้ว ซึ่งค่าของสตริงถูกฮาร์ดโค้ดไว้ในโปรแกรมของเรา ตัวอักษรสตริงนั้นสะดวก แต่ไม่เหมาะสำหรับทุกสถานการณ์ที่เราอาจต้องการใช้ข้อความ 
เหตุผลหนึ่งคือมันเป็นค่าคงที่ (immutable) อีกเหตุผลหนึ่งคือไม่ใช่ทุกค่าสตริงที่จะสามารถทราบได้เมื่อเราเขียนโค้ด ตัวอย่างเช่น ถ้าเราต้องการรับอินพุตจากผู้ใช้และจัดเก็บไว้ล่ะ? 
สำหรับสถานการณ์เหล่านี้ Rust มีชนิดข้อมูลสตริงที่สองคือ `String` ชนิดข้อมูลนี้จัดการข้อมูลที่จัดสรรบนฮีป 
และด้วยเหตุนี้จึงสามารถจัดเก็บข้อความจำนวนเท่าใดก็ได้ที่เราไม่ทราบในเวลาคอมไพล์ คุณสามารถสร้าง `String` จากตัวอักษรสตริงได้โดยใช้ฟังก์ชัน `from` ดังนี้:

```rust
let s = String::from("hello");
```

ตัวดำเนินการทวิภาค `::` ช่วยให้เราสามารถกำหนด namespace ให้กับฟังก์ชัน `from` นี้ภายใต้ชนิดข้อมูล `String` แทนที่จะใช้ชื่ออื่น เช่น `string_from` 
เราจะกล่าวถึงไวยากรณ์นี้เพิ่มเติมในส่วน [“Method
Syntax”][method-syntax]<!-- ignore --> ของบทที่ 5 และเมื่อเราพูดถึงการกำหนด namespace ด้วยโมดูลในส่วน [“Paths for Referring to an Item in the
Module Tree”][paths-module-tree]<!-- ignore --> ในบทที่ 7


สตริงชนิดนี้ _สามารถ_ เปลี่ยนแปลงค่าได้:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

แล้วอะไรคือความแตกต่าง? ทำไม `String` ถึงสามารถเปลี่ยนแปลงค่าได้ แต่ตัวอักษรสตริงทำไม่ได้? ความแตกต่างอยู่ที่วิธีที่ชนิดข้อมูลทั้งสองนี้จัดการกับหน่วยความจำ


### หน่วยความจำและการจัดสรร

ในกรณีของตัวอักษรสตริง เราทราบเนื้อหาในเวลาคอมไพล์ ดังนั้นข้อความจึงถูกฮาร์ดโค้ดโดยตรงลงในไฟล์ปฏิบัติการขั้นสุดท้าย 
นี่คือเหตุผลว่าทำไมตัวอักษรสตริงจึงรวดเร็วและมีประสิทธิภาพ แต่คุณสมบัติเหล่านี้มาจากความเป็นค่าคงที่ของตัวอักษรสตริงเท่านั้น 
น่าเสียดายที่เราไม่สามารถใส่กลุ่มหน่วยความจำลงในไบนารีสำหรับข้อความแต่ละส่วนที่มีขนาดไม่ทราบในเวลาคอมไพล์ และขนาดอาจเปลี่ยนแปลงได้ในขณะที่โปรแกรมกำลังทำงาน

ด้วยชนิดข้อมูล `String` เพื่อรองรับข้อความที่เปลี่ยนแปลงและขยายขนาดได้ เราจำเป็นต้องจัดสรรหน่วยความจำจำนวนหนึ่งบนฮีป ซึ่งไม่ทราบในเวลาคอมไพล์ เพื่อเก็บเนื้อหา ซึ่งหมายความว่า:

- ต้องมีการร้องขอหน่วยความจำจากตัวจัดสรรหน่วยความจำในขณะรันไทม์
- เราต้องการวิธีในการคืนหน่วยความจำนี้ให้กับตัวจัดสรรเมื่อเราใช้งาน `String` เสร็จแล้ว


ส่วนแรกนั้นเราเป็นผู้ดำเนินการ: เมื่อเราเรียกใช้ `String::from` การทำงานของมันจะร้องขอหน่วยความจำที่ต้องการ นี่เป็นเรื่องปกติในภาษาโปรแกรมส่วนใหญ่

อย่างไรก็ตาม ส่วนที่สองนั้นแตกต่างออกไป ในภาษาที่มี ตัวเก็บขยะ (garbage collector - GC) GC จะติดตามและล้างหน่วยความจำที่ไม่ได้ใช้อีกต่อไป
และเราไม่จำเป็นต้องคิดถึงมัน ในภาษาส่วนใหญ่ที่ไม่มี GC เป็นความรับผิดชอบของเราที่จะต้องระบุว่าเมื่อใดที่หน่วยความจำไม่ได้ถูกใช้อีกต่อไป 
และเรียกใช้โค้ดเพื่อคืนหน่วยความจำนั้นอย่างชัดเจน เช่นเดียวกับที่เราทำเพื่อร้องขอ การทำเช่นนี้อย่างถูกต้องในอดีตเป็นปัญหาการเขียนโปรแกรมที่ยาก หากเราลืม 
เราจะสูญเปล่าหน่วยความจำ หากเราทำเร็วเกินไป เราจะมีตัวแปรที่ไม่ถูกต้อง หากเราทำสองครั้ง นั่นก็เป็นข้อผิดพลาดเช่นกัน เราจำเป็นต้องจับคู่การ `allocate` หนึ่งครั้งกับการ `free` หนึ่งครั้งเท่านั้น

Rust ใช้แนวทางที่แตกต่างออกไป: หน่วยความจำจะถูกคืนโดยอัตโนมัติเมื่อตัวแปรที่เป็นเจ้าของมันหลุดออกจากขอบเขต นี่คือตัวอย่างขอบเขตของเราจากรายการที่ 4-1 ที่ใช้ `String` แทนตัวอักษรสตริง:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

มีจุดที่เป็นธรรมชาติที่เราสามารถคืนหน่วยความจำที่ `String` ของเราต้องการให้กับตัวจัดสรรได้ นั่นคือเมื่อ `s` หลุดออกจากขอบเขต 
เมื่อตัวแปรหลุดออกจากขอบเขต Rust จะเรียกฟังก์ชันพิเศษให้เรา ฟังก์ชันนี้เรียกว่า [`drop`][drop]<!-- ignore --> และเป็นที่ที่ผู้สร้าง `String` 
สามารถใส่โค้ดเพื่อคืนหน่วยความจำได้ Rust จะเรียกใช้ `drop` โดยอัตโนมัติเมื่อถึงเครื่องหมายปีกกาปิด (}).

>หมายเหตุ: ใน C++ รูปแบบการยกเลิกการจัดสรรทรัพยากรเมื่อสิ้นสุดอายุการใช้งานของรายการ บางครั้งเรียกว่า _Resource Acquisition Is Initialization (RAII)_ ฟังก์ชัน `drop` ใน Rust จะคุ้นเคยสำหรับคุณ หากคุณเคยใช้รูปแบบ RAII

รูปแบบนี้มีผลกระทบอย่างลึกซึ้งต่อวิธีการเขียนโค้ด Rust ตอนนี้อาจดูเหมือนง่าย แต่พฤติกรรมของโค้ดอาจคาดไม่ถึงในสถานการณ์ที่ซับซ้อนมากขึ้น เมื่อเราต้องการให้ตัวแปรหลายตัวใช้ข้อมูลที่เราจัดสรรไว้บนฮีป มาสำรวจสถานการณ์เหล่านั้นกันเลย

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-move"></a>

#### การทำงานร่วมกันระหว่างตัวแปรและข้อมูลด้วยการย้าย (Move)

ใน Rust ตัวแปรหลายตัวสามารถทำงานร่วมกับข้อมูลเดียวกันได้ในรูปแบบที่แตกต่างกัน มาดูตัวอย่างการใช้จำนวนเต็มใน Listing 4-2 กัน

<Listing number="4-2" caption="Assigning the integer value of variable `x` to `y`">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

</Listing>

เราอาจจะเดาได้ว่าโค้ดนี้ทำอะไร: "ผูกค่า `5` กับ `x`; จากนั้นสร้างสำเนาของค่าใน `x` และผูกมันกับ `y`" ตอนนี้เรามีสองตัวแปรคือ x และ `y` ซึ่งทั้งสองมีค่าเท่ากับ `5` นี่คือสิ่งที่เกิดขึ้นจริง 
เนื่องจากจำนวนเต็มเป็นค่าพื้นฐานที่มีขนาดที่ทราบและคงที่ และค่า `5` ทั้งสองนี้ถูกพุชลงบนสแต็ก

ตอนนี้มาดูเวอร์ชัน `String` กันบ้าง:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```
โค้ดนี้ดูคล้ายกันมาก ดังนั้นเราอาจจะสันนิษฐานว่าวิธีการทำงานจะเหมือนกัน นั่นคือบรรทัดที่สองจะสร้างสำเนาของค่าใน `s1` และผูกมันกับ `s2` แต่นี่ไม่ใช่สิ่งที่เกิดขึ้นจริง

ลองดูรูปที่ 4-1 เพื่อดูว่าเกิดอะไรขึ้นกับ `String` ภายใต้เบื้องหลัง `String` ประกอบด้วยสามส่วนที่แสดงทางด้านซ้าย: พอยน์เตอร์ไปยังหน่วยความจำที่เก็บเนื้อหาของสตริง ความยาว และความจุ กลุ่มข้อมูลนี้ถูกจัดเก็บไว้บนสแต็ก ทางด้านขวาคือหน่วยความจำบนฮีปที่เก็บเนื้อหา


<img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" />

<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>

ความยาวคือปริมาณหน่วยความจำ (ไบต์) ที่เนื้อหาของ `String` กำลังใช้งานอยู่ ความจุคือปริมาณหน่วยความจำทั้งหมด (ไบต์) ที่ `String` ได้รับจากตัวจัดสรร ความแตกต่างระหว่างความยาวและความจุมีความสำคัญ แต่ไม่ใช่ในบริบทนี้ ดังนั้นในตอนนี้ ไม่ต้องสนใจความจุก็ได้

เมื่อเรากำหนด `s1` ให้กับ `s2` ข้อมูล `String` จะถูกคัดลอก ซึ่งหมายถึงเราคัดลอกพอยน์เตอร์ ความยาว และความจุที่อยู่บนสแต็ก เราไม่ได้คัดลอกข้อมูลบนฮีปที่พอยน์เตอร์อ้างถึง กล่าวอีกนัยหนึ่ง การแสดงข้อมูลในหน่วยความจำจะมีลักษณะเหมือนรูปที่ 4-2


<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap."
src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>


การแสดงผล _ไม่ได้_ มีลักษณะเหมือนรูปที่ 4-3 ซึ่งเป็นลักษณะที่หน่วยความจำจะเป็น หาก Rust คัดลอกข้อมูลบนฮีปด้วย หาก Rust ทำเช่นนี้ การดำเนินการ `s2 = s1` อาจมีค่าใช้จ่ายสูงมากในแง่ของประสิทธิภาพการทำงานขณะรันไทม์ หากข้อมูลบนฮีปมีขนาดใหญ่


<img alt="Four tables: two tables representing the stack data for s1 and s2,
and each points to its own copy of string data on the heap."
src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>

ก่อนหน้านี้ เรากล่าวว่าเมื่อตัวแปรหลุดออกจากขอบเขต Rust จะเรียกใช้ฟังก์ชัน `drop` โดยอัตโนมัติและล้างหน่วยความจำฮีปสำหรับตัวแปรนั้น 
แต่รูปที่ 4-2 แสดงให้เห็นว่าพอยน์เตอร์ข้อมูลทั้งสองชี้ไปยังตำแหน่งเดียวกัน นี่เป็นปัญหา: เมื่อ `s2` และ `s1` หลุดออกจากขอบเขต ทั้งสองจะพยายามคืนหน่วยความจำเดียวกัน 
นี่เรียกว่าข้อผิดพลาด _double free_ และเป็นหนึ่งในข้อผิดพลาดด้านความปลอดภัยของหน่วยความจำที่เรากล่าวถึงก่อนหน้านี้ การคืนหน่วยความจำสองครั้งอาจนำไปสู่ความเสียหายของหน่วยความจำ ซึ่งอาจนำไปสู่ช่องโหว่ด้านความปลอดภัยได้

เพื่อให้มั่นใจในความปลอดภัยของหน่วยความจำ หลังจากบรรทัด `let s2 = s1;` Rust จะถือว่า `s1` ไม่ถูกต้องอีกต่อไป ดังนั้น Rust จึงไม่จำเป็นต้องคืนหน่วยความจำใดๆ เมื่อ `s1` 
หลุดออกจากขอบเขต ลองดูสิ่งที่เกิดขึ้นเมื่อคุณพยายามใช้ `s1` หลังจากสร้าง `s2` แล้ว มันจะใช้งานไม่ได้:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

คุณจะได้รับข้อผิดพลาดเช่นนี้ เนื่องจาก Rust ป้องกันไม่ให้คุณใช้การอ้างอิงที่ไม่ถูกต้อง

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

หากคุณเคยได้ยินคำว่า _shallow copy_ (การคัดลอกแบบตื้น) และ _deep copy_ (การคัดลอกแบบลึก) ขณะทำงานกับภาษาอื่นๆ 
แนวคิดของการคัดลอกพอยน์เตอร์ ความยาว และความจุ โดยไม่คัดลอกข้อมูล อาจฟังดูเหมือนเป็นการทำ shallow copy แต่เนื่องจาก Rust ทำให้ตัวแปรแรกไม่ถูกต้องด้วย 
แทนที่จะเรียกว่า shallow copy จึงเรียกว่า _move_ (การย้าย) ในตัวอย่างนี้ เราจะพูดว่า `s1` ถูกย้าย ไปยัง `s2` ดังนั้น สิ่งที่เกิดขึ้นจริงจะแสดงในรูปที่ 4-4

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.svg" class="center" style="width:
50%;" />

<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>

นั่นแก้ปัญหาของเราได้! เมื่อมีเพียง `s2` ที่ถูกต้อง เมื่อมันหลุดออกจากขอบเขต มันเพียงตัวเดียวที่จะคืนหน่วยความจำ และเราก็เสร็จสิ้น

นอกจากนี้ ยังมีการตัดสินใจออกแบบที่แฝงอยู่ในสิ่งนี้ด้วย นั่นคือ Rust จะไม่มีวันสร้างสำเนา "ลึก" ของข้อมูลของคุณโดยอัตโนมัติ ดังนั้นการคัดลอกโดย _อัตโนมัติ_ ใดๆ ก็ตามสามารถถือได้ว่ามีค่าใช้จ่ายต่ำในแง่ของประสิทธิภาพการทำงานขณะรันไทม์

#### ขอบเขตและการกำหนดค่า

สิ่งที่ตรงกันข้ามนี้เป็นจริงสำหรับความสัมพันธ์ระหว่างขอบเขต ความเป็นเจ้าของ และการคืนหน่วยความจำผ่านฟังก์ชัน `drop` ด้วยเช่นกัน เมื่อคุณกำหนดค่าใหม่ทั้งหมดให้กับตัวแปรที่มีอยู่ Rust จะเรียกใช้ `drop` และคืนหน่วยความจำของค่าเดิมทันที ลองพิจารณาโค้ดนี้เป็นตัวอย่าง:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04b-replacement-drop/src/main.rs:here}}
```

ในตอนแรก เราประกาศตัวแปร `s` และผูกมันกับ `String` ที่มีค่า `"hello"` จากนั้นเราสร้าง `String` ใหม่ที่มีค่า `"ahoy"` ทันที และกำหนดให้กับ `s` ณ จุดนี้ ไม่มีสิ่งใดอ้างอิงถึงค่าเดิมบนฮีปอีกเลย

<img alt="One table s representing the string value on the stack, pointing to
the second piece of string data (ahoy) on the heap, with the original string
data (hello) grayed out because it cannot be accessed anymore."
src="img/trpl04-05.svg"
class="center"
style="width: 50%;"
/>

<span class="caption">Figure 4-5: Representation in memory after the initial
value has been replaced in its entirety.</span>

ดังนั้น สตริงเดิมจึงหลุดออกจากขอบเขตทันที Rust จะเรียกใช้ฟังก์ชัน `drop` บนมัน และหน่วยความจำของมันจะถูกคืนทันที เมื่อเราพิมพ์ค่าในตอนท้าย มันจะเป็น `"ahoy, world!"`


<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-clone"></a>

#### การทำงานร่วมกันระหว่างตัวแปรและข้อมูลด้วย Clone

หากเรา ต้องการ คัดลอกข้อมูลบนฮีปของ `String` แบบลึก ไม่ใช่แค่ข้อมูลบนสแต็ก เราสามารถใช้วิธีทั่วไปที่เรียกว่า `clone` เราจะกล่าวถึงไวยากรณ์ของเมธอดในบทที่ 5 แต่เนื่องจากเมธอดเป็นคุณสมบัติทั่วไปในภาษาโปรแกรมหลายภาษา คุณอาจเคยเห็นเมธอดมาก่อน

นี่คือตัวอย่างการใช้งานเมธอด `clone`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

โค้ดนี้ทำงานได้ดีและสร้างพฤติกรรมที่แสดงในรูปที่ 4-3 อย่างชัดเจน ซึ่งข้อมูลบนฮีป ถูก คัดลอก

เมื่อคุณเห็นการเรียกใช้ `clone` คุณจะรู้ว่ามีการดำเนินการโค้ดบางอย่างที่อาจมีค่าใช้จ่ายสูง มันเป็นตัวบ่งชี้ด้วยสายตาว่ามีบางสิ่งที่แตกต่างออกไปเกิดขึ้น

#### Stack-Only Data: Copy

ยังมีรายละเอียดอีกอย่างที่เรายังไม่ได้พูดถึง โค้ดนี้ที่ใช้จำนวนเต็ม ซึ่งบางส่วนแสดงใน Listing 4-2 ทำงานได้และถูกต้อง:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

แต่โค้ดนี้ดูเหมือนจะขัดแย้งกับสิ่งที่เราเพิ่งเรียนรู้ไป: เราไม่มีการเรียกใช้ `clone` แต่ `x` ยังคงใช้งานได้และไม่ได้ถูกย้ายไปยัง `y`

เหตุผลคือชนิดข้อมูล เช่น จำนวนเต็ม ซึ่งมีขนาดที่ทราบในเวลาคอมไพล์ จะถูกจัดเก็บไว้บนสแต็กทั้งหมด ดังนั้นการคัดลอกค่าจริงจึงทำได้อย่างรวดเร็ว 
นั่นหมายความว่าไม่มีเหตุผลที่เราจะต้องการป้องกันไม่ให้ `x` ใช้งานได้หลังจากที่เราสร้างตัวแปร `y` กล่าวอีกนัยหนึ่ง ไม่มีความแตกต่างระหว่างการคัดลอกแบบลึกและการคัดลอกแบบตื้นในที่นี้ ดังนั้นการเรียกใช้ `clone` จะไม่ทำอะไรแตกต่างจากการคัดลอกแบบตื้นตามปกติ และเราสามารถละเว้นมันได้

Rust มีคำอธิบายประกอบพิเศษที่เรียกว่า `Copy` trait ซึ่งเราสามารถวางบนชนิดข้อมูลที่จัดเก็บไว้บนสแต็ก เช่น จำนวนเต็ม (เราจะพูดถึง traits เพิ่มเติมในบทที่ [Chapter 10][traits]<!-- ignore -->) หากชนิดข้อมูลใดชนิดข้อมูลหนึ่งใช้งาน `Copy` trait ตัวแปรที่ใช้ชนิดข้อมูลนั้นจะไม่ถูกย้าย แต่จะถูกคัดลอกอย่างง่าย ทำให้ยังคงใช้งานได้หลังจากกำหนดให้กับตัวแปรอื่น

Rust จะไม่อนุญาตให้เราใส่คำอธิบายประกอบ `Copy` ให้กับชนิดข้อมูล หากชนิดข้อมูลนั้น หรือส่วนใดส่วนหนึ่งของมัน ได้ใช้งาน `Drop` trait หากชนิดข้อมูลต้องการให้มีบางสิ่งพิเศษเกิดขึ้นเมื่อค่าหลุดออกจากขอบเขต 
และเราเพิ่มคำอธิบายประกอบ `Copy` ให้กับชนิดข้อมูลนั้น เราจะได้รับข้อผิดพลาดในเวลาคอมไพล์ หากต้องการเรียนรู้เพิ่มเติมเกี่ยวกับวิธีเพิ่มคำอธิบายประกอบ `Copy` ให้กับชนิดข้อมูลของคุณเพื่อใช้งาน trait โปรดดู [“Derivable
Traits”][derivable-traits]<!-- ignore -->  ในภาคผนวก C

ดังนั้น ชนิดข้อมูลใดบ้างที่ใช้งาน `Copy` trait? คุณสามารถตรวจสอบเอกสารสำหรับชนิดข้อมูลนั้นๆ 
เพื่อให้แน่ใจ แต่โดยทั่วไปแล้ว กลุ่มของค่าสเกลาร์พื้นฐานใดๆ ก็สามารถใช้งาน `Copy` ได้ และไม่มีสิ่งใดที่ต้องการการจัดสรรหรือเป็นทรัพยากรในรูปแบบใดๆ ที่สามารถใช้งาน `Copy` ได้ นี่คือชนิดข้อมูลบางส่วนที่ใช้งาน `Copy`:

- ชนิดข้อมูลจำนวนเต็มทั้งหมด เช่น `u32`
- ชนิดข้อมูลบูลีน `bool` ที่มีค่า `true` และ `false`
- ชนิดข้อมูลทศนิยมทั้งหมด เช่น `f64`
- ชนิดข้อมูลตัวอักษร `char`
- ทูเพิล หากมีเฉพาะชนิดข้อมูลที่ใช้งาน Copy ด้วย ตัวอย่างเช่น (`i32`, `i32`) ใช้งาน `Copy` แต่ (`i32`, `String`) ไม่ได้

### ความเป็นเจ้าของและฟังก์ชัน

กลไกของการส่งค่าไปยังฟังก์ชันคล้ายกับกลไกของการกำหนดค่าให้กับตัวแปร การส่งตัวแปรไปยังฟังก์ชันจะย้ายหรือคัดลอก เช่นเดียวกับการกำหนดค่า Listing 4-3 มีตัวอย่างพร้อมคำอธิบายประกอบที่แสดงว่าตัวแปรเข้าและออกจากขอบเขตที่ใด

<Listing number="4-3" file-name="src/main.rs" caption="Functions with ownership and scope annotated">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

</Listing>

หากเราพยายามใช้ `s` หลังจากเรียกใช้ `takes_ownership` Rust จะแสดงข้อผิดพลาดในเวลาคอมไพล์ การตรวจสอบแบบสแตติกเหล่านี้ช่วยป้องกันเราจากข้อผิดพลาด ลองเพิ่มโค้ดใน `main` ที่ใช้ `s` และ `x` เพื่อดูว่าคุณสามารถใช้งานได้ที่ใด และกฎความเป็นเจ้าของป้องกันไม่ให้คุณทำเช่นนั้นที่ใด


### ค่าที่ส่งคืนและขอบเขต

การส่งคืนค่าก็สามารถถ่ายโอนความเป็นเจ้าของได้เช่นกัน Listing 4-4 แสดงตัวอย่างของฟังก์ชันที่ส่งคืนค่าบางอย่าง พร้อมคำอธิบายประกอบที่คล้ายกับใน Listing 4-3

<Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

</Listing>

ความเป็นเจ้าของของตัวแปรเป็นไปตามรูปแบบเดียวกันทุกครั้ง: การกำหนดค่าให้กับตัวแปรอื่นจะย้ายความเป็นเจ้าของ เมื่อตัวแปรที่มีข้อมูลบนฮีปหลุดออกจากขอบเขต ค่าดังกล่าวจะถูกล้างโดย `drop` เว้นแต่ความเป็นเจ้าของของข้อมูลจะถูกย้ายไปยังตัวแปรอื่น

แม้ว่าวิธีนี้จะใช้งานได้ แต่การรับความเป็นเจ้าของแล้วส่งคืนความเป็นเจ้าของกับทุกฟังก์ชันก็ค่อนข้างน่าเบื่อ จะเกิดอะไรขึ้นถ้าเราต้องการให้ฟังก์ชันใช้ค่าหนึ่ง แต่ไม่ต้องการรับความเป็นเจ้าของ? มันค่อนข้างน่ารำคาญที่อะไรก็ตามที่เราส่งเข้าไปจะต้องถูกส่งกลับมาด้วย หากเราต้องการใช้งานอีกครั้ง นอกเหนือจากข้อมูลใดๆ ที่เป็นผลมาจากเนื้อหาของฟังก์ชันที่เราอาจต้องการส่งคืนด้วย

Rust อนุญาตให้เราส่งคืนค่าหลายค่าโดยใช้ทูเพิล ดังที่แสดงใน Listing 4-5

<Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

</Listing>

แต่นี่เป็นพิธีรีตรองที่มากเกินไปและเป็นงานที่ค่อนข้างหนักสำหรับแนวคิดที่ควรจะเป็นเรื่องปกติ โชคดีสำหรับเรา Rust มีคุณสมบัติสำหรับการใช้ค่าโดยไม่ต้องถ่ายโอนความเป็นเจ้าของ ซึ่งเรียกว่า _references_ (การอ้างอิง)

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
