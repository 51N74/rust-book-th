## ตัวแปรและการเปลี่ยนแปลงได้

ดังที่กล่าวไว้ในส่วน [“Storing Values with
Variables”][storing-values-with-variables]<!-- ignore --> โดยค่าเริ่มต้น ตัวแปรเป็น Immutable นี่เป็นหนึ่งในหลายๆ สิ่งที่ Rust แนะนำให้คุณเขียนโค้ดในลักษณะที่ใช้ประโยชน์จากความปลอดภัยและความง่ายในการทำ Concurrency ที่ Rust มอบให้ อย่างไรก็ตาม คุณยังมีตัวเลือกที่จะทำให้ตัวแปรของคุณเป็น Mutable ได้ มาสำรวจกันว่า Rust สนับสนุนให้คุณชอบ Immutability อย่างไร และทำไมบางครั้งคุณอาจต้องการเลือกที่จะไม่ทำตามนั้น

เมื่อตัวแปรเป็น Immutable เมื่อค่าถูกผูกไว้กับชื่อแล้ว คุณจะไม่สามารถเปลี่ยนค่านั้นได้ เพื่อแสดงให้เห็นถึงสิ่งนี้ ให้สร้างโปรเจกต์ใหม่ชื่อ variables ในไดเรกทอรี _projects_ ของคุณโดยใช้คำสั่ง `cargo new variables`

จากนั้น ในไดเรกทอรี _variables_ ใหม่ของคุณ ให้เปิดไฟล์ _src/main.rs_ และแทนที่โค้ดด้วยโค้ดต่อไปนี้ ซึ่งจะยัง Compile ไม่ได้ในตอนนี้:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

บันทึกและรันโปรแกรมโดยใช้ `cargo run` คุณควรได้รับ Error ดังนี้:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

ตัวอย่างนี้แสดงให้เห็นว่า Compiler ช่วยคุณค้นหา Errors ในโปรแกรมของคุณได้อย่างไร Errors ของ Compiler อาจทำให้หงุดหงิด แต่จริงๆ แล้วมันหมายความว่าโปรแกรมของคุณยัง _ไม่ได้_ ทำในสิ่งที่คุณต้องการอย่างปลอดภัยเท่านั้น มันไม่ได้หมายความว่าคุณไม่ใช่ Programmer ที่ดี! แม้แต่ Rustacean ที่มีประสบการณ์ก็ยังเจอ Errors ของ Compiler

คุณได้รับ Error Message `cannot assign twice to immutable variable x` เพราะคุณพยายามกำหนดค่าที่สองให้กับตัวแปร Immutable `x`


สิ่งสำคัญคือเราได้รับ Compile-time Errors เมื่อเราพยายามเปลี่ยนค่าที่ถูกกำหนดให้เป็น Immutable เพราะสถานการณ์นี้อาจนำไปสู่ Bugs ได้ หากส่วนหนึ่งของโค้ดของเราทำงานโดยสมมติว่าค่าจะไม่เปลี่ยนแปลง และอีกส่วนหนึ่งของโค้ดของเราเปลี่ยนค่านั้น เป็นไปได้ว่าส่วนแรกของโค้ดจะไม่ทำงานตามที่ถูกออกแบบไว้ สาเหตุของ Bug ประเภทนี้อาจติดตามได้ยากในภายหลัง โดยเฉพาะอย่างยิ่งเมื่อโค้ดส่วนที่สองเปลี่ยนค่า _เฉพาะบางครั้ง_ Compiler ของ Rust รับประกันว่าเมื่อคุณระบุว่าค่าจะไม่เปลี่ยนแปลง มันจะไม่เปลี่ยนแปลงจริงๆ ดังนั้นคุณจึงไม่ต้องติดตามด้วยตัวเอง โค้ดของคุณจึงง่ายต่อการทำความเข้าใจ


แต่ Mutability ก็มีประโยชน์มาก และสามารถทำให้โค้ดเขียนได้สะดวกยิ่งขึ้น แม้ว่าตัวแปรจะเป็น Immutable โดยค่าเริ่มต้น แต่คุณสามารถทำให้เป็น Mutable ได้โดยการเพิ่ม `mut` ไว้หน้าชื่อตัวแปร เช่นเดียวกับที่คุณทำใน [Chapter
2][storing-values-with-variables]<!-- ignore --> การเพิ่ม `mut` ยังสื่อถึงความตั้งใจให้กับผู้อ่านโค้ดในอนาคต โดยระบุว่าส่วนอื่นๆ ของโค้ดจะเปลี่ยนแปลงค่าของตัวแปรนี้


 จากตัวอย่าง, เปลี่ยนโค้ดในไฟล์ _src/main.rs_ ดังนี้:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```
เมื่อเรารันโปรแกรม เราควรจะได้

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```


เราได้รับอนุญาตให้เปลี่ยนค่าที่ผูกไว้กับ `x` จาก `5` เป็น `6` เมื่อมีการใช้ `mut` ท้ายที่สุด การตัดสินใจว่าจะใช้ Mutability หรือไม่นั้นขึ้นอยู่กับคุณ และขึ้นอยู่กับสิ่งที่คุณคิดว่าชัดเจนที่สุดในสถานการณ์นั้นๆ ครับ

### ค่าคงที่ (Constants)

เช่นเดียวกับตัวแปร Immutable _ค่าคงที่_ (Constants) คือค่าที่ถูกผูกไว้กับชื่อและไม่อนุญาตให้เปลี่ยนแปลง แต่มีข้อแตกต่างบางประการระหว่างค่าคงที่และตัวแปร

ประการแรก คุณไม่ได้รับอนุญาตให้ใช้ `mut` กับค่าคงที่ ค่าคงที่ไม่ใช่แค่ Immutable โดยค่าเริ่มต้น แต่เป็น Immutable เสมอไป คุณประกาศค่าคงที่โดยใช้ Keyword `const` แทนที่จะเป็น Keyword `let` และ _ต้อง_ มีการระบุ Type ของค่า (Type Annotation) เราจะกล่าวถึง Type และ Type Annotation ในส่วนถัดไป [“Data Types”][data-types]<!-- ignore -->, ดังนั้นไม่ต้องกังวลเกี่ยวกับรายละเอียดในตอนนี้ เพียงแค่รู้ว่าคุณต้องระบุ Type เสมอ

ค่าคงที่สามารถประกาศได้ใน Scope ใดก็ได้ รวมถึง Global Scope ซึ่งทำให้มีประโยชน์สำหรับค่าที่โค้ดหลายส่วนจำเป็นต้องทราบ

ความแตกต่างสุดท้ายคือ ค่าคงที่สามารถกำหนดได้เฉพาะ Constant Expression เท่านั้น ไม่ใช่ผลลัพธ์ของค่าที่สามารถคำนวณได้เฉพาะใน Runtime

นี่คือตัวอย่างการประกาศค่าคงที่:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

ชื่อของค่าคงที่คือ `THREE_HOURS_IN_SECONDS` และค่าของมันถูกกำหนดให้เป็นผลลัพธ์ของการคูณ 60 (จำนวนวินาทีในหนึ่งนาที) ด้วย 60 (จำนวนนาทีในหนึ่งชั่วโมง) ด้วย 3 (จำนวนชั่วโมงที่เราต้องการนับในโปรแกรมนี้) รูปแบบการตั้งชื่อค่าคงที่ของ Rust คือการใช้อักษรตัวพิมพ์ใหญ่ทั้งหมดโดยมี Underscore คั่นระหว่างคำ Compiler สามารถประเมินชุดของการดำเนินการที่จำกัดได้ใน Compile Time ซึ่งช่วยให้เราสามารถเขียนค่านี้ในลักษณะที่เข้าใจและตรวจสอบได้ง่าย แทนที่จะกำหนดค่าคงที่นี้เป็น 10,800 โปรดดูส่วนการประเมินค่าคงที่ใน Rust Reference สำหรับข้อมูลเพิ่มเติมเกี่ยวกับการดำเนินการที่สามารถใช้ได้เมื่อประกาศค่าคงที่

ค่าคงที่นั้นมีผลตลอดระยะเวลาที่โปรแกรมทำงาน ภายใน Scope ที่ถูกประกาศ คุณสมบัตินี้ทำให้ค่าคงที่มีประโยชน์สำหรับค่าต่างๆ ใน Domain ของ Application ของคุณที่โค้ดหลายส่วนอาจจำเป็นต้องทราบ เช่น คะแนนสูงสุดที่ผู้เล่นเกมใดๆ สามารถได้รับ หรือความเร็วแสง

การตั้งชื่อค่า Hardcode ที่ใช้ทั่วทั้งโปรแกรมของคุณเป็นค่าคงที่มีประโยชน์ในการสื่อความหมายของค่านั้นให้กับผู้ดูแลโค้ดในอนาคต นอกจากนี้ยังช่วยให้มีเพียงตำแหน่งเดียวในโค้ดของคุณที่คุณจะต้องเปลี่ยนแปลง หากค่า Hardcode นั้นจำเป็นต้องได้รับการอัปเดตในอนาคต

### การ Shadowing

ดังที่คุณได้เห็นใน Tutorial เกมทายตัวเลขใน [Chapter
2][comparing-the-guess-to-the-secret-number]<!-- ignore --> คุณสามารถประกาศตัวแปรใหม่ด้วยชื่อเดียวกับตัวแปรเดิมได้ Rustaceans กล่าวว่าตัวแปรแรกถูก Shadow โดยตัวแปรที่สอง ซึ่งหมายความว่าตัวแปรที่สองคือสิ่งที่ Compiler จะเห็นเมื่อคุณใช้ชื่อตัวแปรนั้น กล่าวโดยสรุปคือ ตัวแปรที่สองจะบดบังตัวแปรแรก โดยนำการใช้งานชื่อตัวแปรทั้งหมดมาที่ตัวเอง จนกว่าตัวมันเองจะถูก Shadow หรือ Scope สิ้นสุดลง เราสามารถ Shadow ตัวแปรได้โดยใช้ชื่อตัวแปรเดิมซ้ำและใช้ Keyword `let` อีกครั้ง ดังนี้:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

โปรแกรมนี้เริ่มต้นด้วยการผูกค่า `5` ให้กับตัวแปร `x` จากนั้นสร้างตัวแปรใหม่ชื่อ `x` โดยการใช้ `let x =` ซ้ำ นำค่าเดิมของ x มาบวก `1` ทำให้ค่าของ `x` กลายเป็น `6` จากนั้น ภายใน Inner Scope ที่สร้างด้วยวงเล็บปีกกา คำสั่ง `let` ที่สามก็ Shadow ตัวแปร `x` อีกครั้ง และสร้างตัวแปรใหม่ โดยนำค่าก่อนหน้ามาคูณ `2` ทำให้ `x` มีค่าเป็น `12` เมื่อ Scope นั้นสิ้นสุดลง การ Shadow ภายในก็จะสิ้นสุดลง และ `x` จะกลับไปเป็น `6` เมื่อเรารันโปรแกรมนี้ มันจะแสดงผลลัพธ์ดังนี้:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```
การ Shadow แตกต่างจากการทำเครื่องหมายตัวแปรด้วย `mut` เพราะเมื่อเราไม่บังเอิญกำหนดค่าใหม่ให้กับตัวแปรอีกครั้ง หากเราไม่ได้ใช้ Keyword `let` การสร้างตัวแปรใหม่ด้วยชื่อเดียวกัน จะทำให้เกิด Compile-time Error โดยการใช้ `let` เราสามารถทำการแปลง Type ของค่าได้ แต่ยังคงรักษาชื่อตัวแปรเดิมไว้ ตัวอย่างเช่น ในเกมทายตัวเลข เรา Shadow guess จาก String เป็น u32 ดังนี้:


ความแตกต่างอีกอย่างระหว่าง `mut` และการ `Shadow` คือเนื่องจากเรากำลังสร้างตัวแปรใหม่เมื่อเราใช้ Keyword `let` อีกครั้ง เราจึงสามารถเปลี่ยน `Type` ของค่าได้ แต่ยังคงใช้ชื่อเดิมได้ ตัวอย่างเช่น สมมติว่าโปรแกรมของเราขอให้ผู้ใช้ระบุจำนวน Space ที่ต้องการระหว่างข้อความโดยการป้อน Character Space และจากนั้นเราต้องการเก็บ Input นั้นเป็นตัวเลข:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

ตัวแปร `spaces` แรกเป็น Type String และตัวแปร spaces ที่สองเป็น Type `ตัวเลข` ดังนั้นการ Shadow จึงช่วยให้เราไม่ต้องคิดชื่อที่แตกต่างกัน เช่น `spaces_str` และ `spaces_num ` แต่เราสามารถใช้ชื่อที่เรียบง่ายกว่าอย่าง `spaces` ได้ อย่างไรก็ตาม หากเราพยายามใช้ mut สำหรับกรณีนี้ ดังที่แสดงไว้ที่นี่ เราจะได้รับ Compile-time Error:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

Error แสดงข้อผิดพลาดว่าเราไม่สามารถเปลี่ยนค่าตัวแปรได้:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

หลังจากที่เราได้สำรวจวิธีการทำงานของตัวแปรแล้ว ต่อไปเรามาดู Data Types อื่นๆ ที่ตัวแปรเหล่านั้นสามารถมีได้กันครับ

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
