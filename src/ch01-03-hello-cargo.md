## Hello, Cargo!

Cargo เป็นระบบ Build และ Package Manager ของ Rust Rustaceans ส่วนใหญ่ใช้เครื่องมือนี้เพื่อจัดการโปรเจกต์ Rust ของตน เนื่องจาก Cargo จัดการงานต่างๆ ให้คุณมากมาย เช่น การ Build โค้ดของคุณ การดาวน์โหลดไลบรารีที่โค้ดของคุณต้องพึ่งพา และการ Build ไลบรารีเหล่านั้น (เราเรียกไลบรารีที่โค้ดของคุณต้องการว่า _dependencies_)

โปรแกรม Rust ที่ง่ายที่สุด เช่น โปรแกรมที่เราเขียนไปแล้วนั้นไม่มี dependencies หากเราสร้างโปรเจกต์ "Hello, world!" ด้วย Cargo มันจะใช้เพียงส่วนของ Cargo ที่จัดการการ Build โค้ดของคุณเท่านั้น เมื่อคุณเขียนโปรแกรม Rust ที่ซับซ้อนมากขึ้น คุณจะเพิ่ม dependencies และหากคุณเริ่มต้นโปรเจกต์โดยใช้ Cargo การเพิ่ม dependencies จะทำได้ง่ายขึ้นมาก

เนื่องจากโปรเจกต์ Rust ส่วนใหญ่ใช้ Cargo ส่วนที่เหลือของหนังสือเล่มนี้จึงถือว่าคุณกำลังใช้ Cargo ด้วย Cargo จะถูกติดตั้งพร้อมกับ Rust หากคุณใช้ตัวติดตั้งอย่างเป็นทางการที่กล่าวถึงในส่วน ["การติดตั้ง"][installation]<!-- ignore --> หากคุณติดตั้ง Rust ด้วยวิธีอื่น ให้ตรวจสอบว่า Cargo ถูกติดตั้งแล้วหรือไม่ โดยป้อนคำสั่งต่อไปนี้ในเทอร์มินัลของคุณ:

```console
$ cargo --version
```

หากคุณเห็นข้อมูลนี้ แสดงว่าคุณได้ติดตั้ง Cargo สำเร็จแล้ว หากคุณไม่เห็นข้อความแสดงข้อผิดพลาด แสดงว่า Cargo ไม่ได้ถูกติดตั้ง คุณควรกลับไปที่ส่วนการติดตั้งและติดตั้ง Rust อีกครั้งโดยใช้ rustup

### การสร้างโปรเจกต์ด้วย Cargo

มาสร้างโปรเจกต์ใหม่โดยใช้ Cargo และดูว่ามันแตกต่างจากโปรเจกต์ "Hello, world!" ดั้งเดิมของเราอย่างไร กลับไปยังไดเรกทอรี _projects_ ของคุณ (หรือที่ใดก็ตามที่คุณตัดสินใจเก็บโค้ดของคุณ) จากนั้น บนระบบปฏิบัติการใดก็ได้ ให้รันคำสั่งต่อไปนี้:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

คำสั่งแรกจะสร้างไดเรกทอรีและโปรเจกต์ใหม่ชื่อ hello_cargo เราตั้งชื่อโปรเจกต์ของเราว่า hello_cargo และ Cargo จะสร้างไฟล์ต่างๆ ในไดเรกทอรีที่มีชื่อเดียวกัน

เข้าไปในไดเรกทอรี hello_cargo และแสดงรายการไฟล์ คุณจะเห็นว่า Cargo ได้สร้างไฟล์สองไฟล์และหนึ่งไดเรกทอรีให้เรา: ไฟล์ _Cargo.toml_ และไดเรกทอรี _src_ ที่มีไฟล์ _main.rs_ อยู่ภายใน

นอกจากนี้ Cargo ยังได้เริ่มต้น Git repository ใหม่พร้อมกับไฟล์ _.gitignore_ ไฟล์ Git จะไม่ถูกสร้างขึ้นหากคุณรัน `cargo new` ภายใน Git repository ที่มีอยู่ คุณสามารถลบล้างพฤติกรรมนี้ได้โดยใช้ `cargo new --vcs=git`

Git เป็นระบบควบคุมเวอร์ชันที่ใช้กันทั่วไป คุณสามารถเปลี่ยน cargo new ให้ใช้ระบบควบคุมเวอร์ชันอื่นหรือไม่มีระบบควบคุมเวอร์ชันเลยก็ได้ โดยใช้ Flag --vcs รัน cargo new --help เพื่อดูตัวเลือกที่มี

> หมายเหตุ: Git เป็นระบบควบคุมเวอร์ชันที่ใช้กันทั่วไป คุณสามารถเปลี่ยน `cargo new` ให้ใช้ระบบควบคุมเวอร์ชันอื่นหรือไม่มีระบบควบคุมเวอร์ชันเลยก็ได้ โดยใช้ Flag `--vcs` รัน `cargo new --help` เพื่อดูตัวเลือกที่มี

เปิดไฟล์ _Cargo.toml_ ในโปรแกรมแก้ไขข้อความที่คุณเลือก มันควรมีลักษณะคล้ายกับโค้ดใน Listing 1-2

<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

</Listing>

ไฟล์นี้อยู่ในรูปแบบ [_TOML_][toml]<!-- ignore --> (_Tom’s Obvious, Minimal
Language_) ซึ่งเป็นรูปแบบการกำหนดค่าของ Cargo

บรรทัดแรก `[package]`เป็นส่วนหัวที่ระบุว่าคำสั่งต่อไปนี้กำลังกำหนดค่าแพ็กเกจ เมื่อเราเพิ่มข้อมูลลงในไฟล์นี้มากขึ้น เราจะเพิ่มส่วนอื่นๆ

สามบรรทัดถัดมาตั้งค่าข้อมูลการกำหนดค่าที่ Cargo ต้องการเพื่อคอมไพล์โปรแกรมของคุณ: ชื่อ, เวอร์ชัน และ Edition ของ Rust ที่จะใช้ เราจะพูดถึงคีย์ edition ใน ภาคผนวก E

สามบรรทัดถัดมาตั้งค่าข้อมูลการกำหนดค่าที่ Cargo ต้องการเพื่อคอมไพล์โปรแกรมของคุณ: ชื่อ, เวอร์ชัน และ Edition ของ Rust ที่จะใช้ เราจะพูดถึงคีย์ `edition` ใน ภาคผนวก E [Appendix E][appendix-e]<!--ignore -->.

บรรทัดสุดท้าย `[dependencies]` เป็นจุดเริ่มต้นของส่วนที่คุณจะระบุ Dependencies ใดๆ ของโปรเจกต์ของคุณ ใน Rust แพ็กเกจของโค้ดเรียกว่า _crates_ เราจะไม่ต้องการ crates อื่นๆ สำหรับโปรเจกต์นี้ แต่เราจะต้องการในโปรเจกต์แรกในบทที่ 2 ดังนั้นเราจะใช้ส่วน dependencies นี้ในตอนนั้น

Now open _src/main.rs_ and take a look:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo ได้สร้างโปรแกรม "Hello, world!" ให้คุณแล้ว เหมือนกับโปรแกรมที่เราเขียนใน Listing 1-1! จนถึงตอนนี้ ความแตกต่างระหว่างโปรเจกต์ของเรากับโปรเจกต์ที่ Cargo สร้างขึ้นคือ Cargo ได้วางโค้ดไว้ในไดเรกทอรี _src_ และเรามีไฟล์กำหนดค่า _Cargo.toml_ ในไดเรกทอรีระดับบนสุด

Cargo คาดหวังว่าไฟล์ Source ของคุณจะอยู่ในไดเรกทอรี _src_ ไดเรกทอรีโปรเจกต์ระดับบนสุดมีไว้สำหรับไฟล์ README, ข้อมูลลิขสิทธิ์, ไฟล์กำหนดค่า และสิ่งอื่นๆ ที่ไม่เกี่ยวข้องกับโค้ดของคุณ การใช้ Cargo ช่วยให้คุณจัดระเบียบโปรเจกต์ของคุณ มีที่สำหรับทุกสิ่ง และทุกสิ่งอยู่ในที่ของมัน

หากคุณเริ่มต้นโปรเจกต์ที่ไม่ได้ใช้ Cargo เหมือนที่เราทำกับโปรเจกต์ "Hello, world!" คุณสามารถแปลงให้เป็นโปรเจกต์ที่ใช้ Cargo ได้ ย้ายโค้ดโปรเจกต์ไปยังไดเรกทอรี _src_ และสร้างไฟล์ Cargo.toml ที่เหมาะสม วิธีง่ายๆ ในการสร้างไฟล์ _Cargo.toml_ คือการรันคำสั่ง `cargo init` ซึ่งจะสร้างให้คุณโดยอัตโนมัติ

### การ Build และรันโปรเจกต์ Cargo

ตอนนี้มาดูกันว่ามีอะไรแตกต่างออกไปเมื่อเรา Build และรันโปรแกรม "Hello, world!" ด้วย Cargo! จากไดเรกทอรี hello_cargo ของคุณ ให้ Build โปรเจกต์ของคุณโดยป้อนคำสั่งต่อไปนี้:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

คำสั่งนี้จะสร้างไฟล์ปฏิบัติการใน target/debug/hello_cargo (หรือ target\debug\hello_cargo.exe บน Windows) แทนที่จะอยู่ในไดเรกทอรีปัจจุบันของคุณ เนื่องจาก Build เริ่มต้นเป็นการ Build แบบ Debug Cargo จึงวาง Binary ไว้ในไดเรกทอรีชื่อ _debug_ คุณสามารถรันไฟล์ปฏิบัติการด้วยคำสั่งนี้:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

หากทุกอย่างเป็นไปด้วยดี ข้อความ `Hello, world!` ควรจะแสดงในเทอร์มินัล การรัน cargo build เป็นครั้งแรกยังทำให้ Cargo สร้างไฟล์ใหม่ในระดับบนสุดด้วย: _Cargo.lock_ ไฟล์นี้จะติดตามเวอร์ชันที่แน่นอนของ Dependencies ในโปรเจกต์ของคุณ โปรเจกต์นี้ไม่มี Dependencies ดังนั้นไฟล์นี้จึงค่อนข้างว่างเปล่า คุณไม่จำเป็นต้องแก้ไขไฟล์นี้ด้วยตนเอง Cargo จะจัดการเนื้อหาของมันให้คุณ

เราเพิ่ง Build โปรเจกต์ด้วย `cargo build` และรันด้วย `./target/debug/hello_cargo` แต่เรายังสามารถใช้ `cargo run` เพื่อคอมไพล์โค้ดแล้วรันไฟล์ปฏิบัติการที่ได้ในคำสั่งเดียวได้ด้วย:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

การใช้ `cargo run` สะดวกกว่าการต้องจำที่จะรัน cargo build แล้วใช้ Path ทั้งหมดไปยัง Binary ดังนั้นนักพัฒนาส่วนใหญ่จึงใช้ cargo run

สังเกตว่าครั้งนี้เราไม่เห็น Output ที่บ่งชี้ว่า Cargo กำลังคอมไพล์ `hello_cargo` Cargo ตรวจพบว่าไฟล์ไม่ได้เปลี่ยนแปลง ดังนั้นจึงไม่ได้ Rebuild แต่เพียงรัน Binary หากคุณแก้ไข Source Code ของคุณ Cargo จะ Rebuild โปรเจกต์ก่อนที่จะรัน และคุณจะเห็น Output นี้:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo ยังมีคำสั่งที่เรียกว่า `cargo check` คำสั่งนี้จะตรวจสอบโค้ดของคุณอย่างรวดเร็วเพื่อให้แน่ใจว่าสามารถคอมไพล์ได้ แต่จะไม่สร้างไฟล์ปฏิบัติการ:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

ทำไมคุณถึงไม่อยากได้ไฟล์ปฏิบัติการ? บ่อยครั้งที่ `cargo check` เร็วกว่า `cargo build` มาก เนื่องจากมันข้ามขั้นตอนการสร้างไฟล์ปฏิบัติการ หากคุณตรวจสอบงานของคุณอย่างต่อเนื่องในขณะที่เขียนโค้ด การใช้ `cargo check` จะช่วยเร่งกระบวนการแจ้งให้คุณทราบว่าโปรเจกต์ของคุณยังคอมไพล์ได้หรือไม่! ดังนั้น Rustaceans หลายคนจึงรัน `cargo check` เป็นระยะๆ ในขณะที่เขียนโปรแกรมเพื่อให้แน่ใจว่าคอมไพล์ได้ จากนั้นจึงรัน `cargo build` เมื่อพร้อมที่จะใช้ไฟล์ปฏิบัติการ


มาสรุปสิ่งที่เราได้เรียนรู้เกี่ยวกับ Cargo จนถึงตอนนี้:

- เราสามารถสร้างโปรเจกต์ได้โดยใช้  `cargo new`.
- เราสามารถ Build โปรเจกต์ได้โดยใช้ `cargo build`.
- เราสามารถ Build และรันโปรเจกต์ได้ในขั้นตอนเดียวโดยใช้ `cargo run`.
- เราสามารถ Build โปรเจกต์โดยไม่สร้าง Binary เพื่อตรวจสอบข้อผิดพลาดได้โดยใช้
  `cargo check`.
- แทนที่จะบันทึกผลลัพธ์ของการ Build ในไดเรกทอรีเดียวกับโค้ดของเรา Cargo จะจัดเก็บไว้ในไดเรกทอรี _target/debug_ 

ข้อดีอีกประการของการใช้ Cargo คือคำสั่งต่างๆ จะเหมือนกันไม่ว่าคุณจะทำงานบนระบบปฏิบัติการใดก็ตาม ดังนั้น ณ จุดนี้ เราจะไม่ให้คำแนะนำเฉพาะสำหรับ Linux และ macOS เทียบกับ Windows อีกต่อไป

### การ Build สำหรับการเผยแพร่

เมื่อโปรเจกต์ของคุณพร้อมสำหรับการเผยแพร่แล้ว คุณสามารถใช้ cargo build --release เพื่อคอมไพล์ด้วยการปรับแต่งประสิทธิภาพ คำสั่งนี้จะสร้างไฟล์ปฏิบัติการใน _target/release_ แทนที่จะเป็น _target/debug_ การปรับแต่งประสิทธิภาพจะทำให้โค้ด Rust ของคุณทำงานได้เร็วขึ้น แต่การเปิดใช้งานจะทำให้เวลาในการคอมไพล์โปรแกรมของคุณนานขึ้น นี่คือเหตุผลว่าทำไมจึงมีสองโปรไฟล์ที่แตกต่างกัน: โปรไฟล์หนึ่งสำหรับการพัฒนา เมื่อคุณต้องการ Rebuild อย่างรวดเร็วและบ่อยครั้ง และอีกโปรไฟล์หนึ่งสำหรับการ Build โปรแกรมสุดท้ายที่คุณจะมอบให้กับผู้ใช้ ซึ่งจะไม่ถูก Rebuild ซ้ำๆ และจะทำงานให้เร็วที่สุด หากคุณกำลัง Benchmark เวลาในการรันโค้ดของคุณ อย่าลืมรัน `cargo build --release` และ Benchmark ด้วยไฟล์ปฏิบัติการใน _target/release_

### Cargo ในฐานะข้อตกลง

สำหรับโปรเจกต์ง่ายๆ Cargo อาจไม่ได้ให้คุณค่ามากนักเมื่อเทียบกับการใช้ `rustc` เพียงอย่างเดียว แต่มันจะพิสูจน์คุณค่าของมันเมื่อโปรแกรมของคุณซับซ้อนมากขึ้น เมื่อโปรแกรมมีหลายไฟล์หรือต้องการ Dependency การให้ Cargo ประสานงานการ Build จะง่ายกว่ามาก

แม้ว่าโปรเจกต์ `hello_cargo` จะเรียบง่าย แต่ตอนนี้มันใช้เครื่องมือจริงส่วนใหญ่ที่คุณจะได้ใช้ตลอดอาชีพการเขียนโปรแกรม Rust ของคุณ อันที่จริง ในการทำงานกับโปรเจกต์ที่มีอยู่ คุณสามารถใช้คำสั่งต่อไปนี้เพื่อ Checkout โค้ดโดยใช้ Git เปลี่ยนไปยังไดเรกทอรีของโปรเจกต์นั้น และ Build:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ Cargo โปรดดู [its documentation][cargo].

## สรุป

คุณได้เริ่มต้นการเดินทางสู่ Rust ได้อย่างยอดเยี่ยมแล้ว! ในบทนี้ คุณได้เรียนรู้วิธี:

- ติดตั้ง Rust เวอร์ชันเสถียรล่าสุดโดยใช้ `rustup`
- อัปเดตเป็น Rust เวอร์ชันใหม่กว่า
- เปิดเอกสารประกอบที่ติดตั้งในเครื่อง
- เขียนและรันโปรแกรม "Hello, world!" โดยใช้ `rustc`
- สร้างและรันโปรเจกต์ใหม่โดยใช้ข้อตกลงของ Cargo

นี่เป็นเวลาที่ดีที่จะสร้างโปรแกรมที่ซับซ้อนมากขึ้นเพื่อทำความคุ้นเคยกับการอ่านและเขียนโค้ด Rust ดังนั้นในบทที่ 2 เราจะสร้างโปรแกรมเกมทายตัวเลข หากคุณต้องการเริ่มต้นด้วยการเรียนรู้วิธีการทำงานของแนวคิดการเขียนโปรแกรมทั่วไปใน Rust โปรดดูบทที่ 3 แล้วกลับมาที่บทที่ 2

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
